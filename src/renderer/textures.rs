use glium;
use image;


use glium::texture::Texture2d;
use std::collections::BTreeMap;
use std::fs;
use std::path;

type Tex2d = glium::texture::Texture2d;
type TexMap = BTreeMap<String, Tex2d>;


// this is a module to manage textures, stored in a context
// will map a name to a device 
pub struct TextureMgr{
    map: TexMap,
}

impl TextureMgr{

    fn new () -> TextureMgr {
        TextureMgr{
            map: TexMap::new()
        }
    }

    fn create_texture<F: glium::backend::Facade>(&mut self,
												 display: &F,
                                                 name: &str,
                                                 img: image::RgbaImage) -> &glium::texture::Texture2d {
		use std::fs;

		let image_dimensions = img.dimensions();

		let image = glium::texture::RawImage2d::from_raw_rgba(img.into_raw(), image_dimensions);
    	let texture = glium::texture::Texture2d::with_mipmaps(display, image,
                 glium::texture::MipmapsOption::AutoGeneratedMipmaps).unwrap();

        let key = String::from(name);
        self.map.insert(key.clone(), texture);
        self.map.get(&key).unwrap()
	}

    fn get_texture(&self, name: &str) -> Option<&glium::texture::Texture2d>{
        let key = String::from(name);
        self.map.get(&key)
    }
}



#[cfg(test)]
mod tests {

    use super::TextureMgr;

	use std::fs;
	use std::path::PathBuf;
	use std::path::Path;
	use image;
    use glium::glutin::HeadlessRendererBuilder;
    use glium::DisplayBuild;

    #[test]
    fn test1() {
        TextureMgr::new();
    }

    #[test]
    fn loadImg() {

        let ctx = HeadlessRendererBuilder::new(100,100).build_glium().unwrap();

        let mut path = fs::canonicalize(".").unwrap();
        path.push("assets");
        path.push("test.png");
        let image = image::open(path.as_path()).unwrap();
        
        let mut mgr = TextureMgr::new();
        mgr.create_texture(&ctx, "test", image.to_rgba());

        let _ = mgr.get_texture("test").unwrap();
        if let Some(_) =  mgr.get_texture("testfail"){
            assert!(false, "this is an error");
        }

    }

	
}
