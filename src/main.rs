
#[macro_use]
extern crate glium;
extern crate rand;
extern crate cgmath;
extern crate image;
extern crate glutin;

mod world;
mod utils;
mod renderer;
 
 #[warn(unused_imports)] 
use cgmath::{Point3, Vector3, Matrix4, Euler, deg, Quaternion, perspective};
use utils::load_shader;
use world::cube;
use renderer::context;
use renderer::camera;
//use rand::Rng;

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

const WINDOW_WIDTH: u32 = 1920;
const WINDOW_HEIGHT: u32 = 1080;

fn main() {

    let window_ratio: f32 = WINDOW_WIDTH as f32 / WINDOW_HEIGHT as f32;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let mut ctx = context::Context::new(WINDOW_WIDTH, WINDOW_HEIGHT);

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let vertex_shader = load_shader("geom.vs");
    let fragment_shader = load_shader("geom.fs");

    let program = match (vertex_shader, fragment_shader) {
        (Ok(a), Ok(b)) => glium::Program::from_source(ctx.display(), &a, &b, None).unwrap(),
        _ => panic!("could not find shaders"),
    };

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let cube = cube::Cube::new(ctx.display()).unwrap();

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    let axis_plot = utils::Axis::new(ctx.display());

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    print!("load atlas:\n");
    let atlas = world::textures::load_atlas("tex_pack").unwrap();
    //let atlas_count = atlas.count;
    let atlas_side = atlas.side;
    let image_dimensions = atlas.image.dimensions();
    let image = glium::texture::RawImage2d::from_raw_rgba(atlas.image.into_raw(), image_dimensions);
    // let atlas_texture = glium::texture::Texture2d::new(ctx.display(), image).unwrap();
    let atlas_texture = glium::texture::Texture2d::with_mipmaps(ctx.display(), image,
                 glium::texture::MipmapsOption::AutoGeneratedMipmaps).unwrap();
    print!("loaded {} mipmaps:\n", atlas_texture.get_mipmap_levels());

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    print!("load height map \n");
    // read height map 
    let height = world::textures::load_rgb("assets/height.jpg");
    let dimensions = height.dimensions();

    // translations for the instances
    let size_x = dimensions.0;
    let size_z = dimensions.1;
    let mut translations: Vec<(f32, f32, f32)> = Vec::new();
    for x in 0..size_x {
        for y in 0..size_z {
            use image::Pixel;

        // get height in coordinates x,y
            let pixel = height.get_pixel(x,y);
            let components = pixel.channels();
            translations.push((x as f32, y as f32, ((components[0] as f32/5.0) as i32) as f32));
        }
    }


    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // building the vertex buffer with the attributes per instance
    let instance_attr : context::VerticesT = {

        #[derive(Copy, Clone, Debug)]
        struct Attr {
            world_position: (f32, f32, f32),
            in_color: (f32, f32, f32),
            tex_offset: (f32, f32),
        }
        implement_vertex!(Attr, world_position, in_color, tex_offset);

        //let mut rng = rand::thread_rng();
        let mut count = 0;
        let data = translations.iter()
            .map(|pos| {

                let tex_id = 2;// rng.gen_range(0, atlas_count);
                count += 1;
                let i_off = ((tex_id / atlas_side) as f32) / atlas_side as f32;
                let j_off = ((tex_id % atlas_side) as f32) / atlas_side as f32;

                //   print!("{}  {},{} @ {},{}\n", tex_id,
                //                                 (tex_id % atlas_side), (tex_id / atlas_side),
                //                                 i_off, j_off);

                Attr {
                    world_position: (pos.0, pos.2, pos.1),
                    in_color: (rand::random(), rand::random(), rand::random()),
                    tex_offset: (i_off as f32, j_off as f32),
                }
            })
            .collect::<Vec<_>>();

        glium::vertex::VertexBuffer::dynamic(ctx.display(), &data).unwrap().into()
    };
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    // generate camera...
	let mut cam =  camera::Camera::new();
    
    const NEAR : f32 = 5.0;
    const FAR : f32 = 1500.0;

    let mut perspective_matrix: Matrix4<f32> = perspective(deg(45.0), window_ratio, NEAR, FAR);
    let mut model_matrix: Matrix4<f32> =
        Matrix4::from_translation(Vector3::new(-(size_x as f32 / 2.0), 0.0, -(size_z as f32 / 2.0)));

    // per increment rotation
    let rotation = Matrix4::from(Quaternion::from(Euler {
        x: deg(0.0),
        y: deg(0.01),
        z: deg(0.0),
    }));

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    print!("{} instances\n", translations.len());

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~ RENDER LOOP ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    use renderer::context::DrawSurface;
    use renderer::context::RenderType;
    let mut run = true;
    let mut render_kind = RenderType::Textured;

    utils::loop_with_report(&mut|delta:f64| {

        cam.update(delta as f32);

		let cam_mat : Matrix4<f32> = cam.into();
        let view_matrix = cam_mat * Matrix4::from_translation(Vector3::new(0.0, 0.0, 0.0));

        if run {
            model_matrix = rotation * model_matrix;
        }

        // TODO: split this in ctx(perspective), view(camera) and world(in the world)
        let uniforms = uniform! {
			perspective_matrix: Into::<[[f32; 4]; 4]>::into(perspective_matrix),
			view_matrix:        Into::<[[f32; 4]; 4]>::into(view_matrix),
			model_matrix:       Into::<[[f32; 4]; 4]>::into(model_matrix),

            atlas_texture: &atlas_texture,
            atlas_side:    atlas_side as u32,
        };

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //    render using the new context 
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
        DrawSurface::gl_begin(&ctx, render_kind)
                        .draw(&axis_plot, &uniforms)
                        .draw_instanciated_with_indices_and_program(&cube, 
                                                                    &instance_attr, 
                                                                    &program, 
                                                                    &uniforms)
                    .gl_end();

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        //    event handling
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        // listing the events produced by the window and waiting to be received
        let mut resizes = Vec::new();
        {
            let events = ctx.display().poll_events();
            for ev in events {

                use glium::glutin::Event;
                use glium::glutin::ElementState;
                match ev {
                    Event::Closed => std::process::exit(0),  // the window has been closed 
                    Event::KeyboardInput(_, 9, _) => std::process::exit(0),  // esc
                    Event::KeyboardInput(ElementState::Released, 33, _) => run = !run,
                    Event::KeyboardInput(ElementState::Released, 32, _)
                        => render_kind = RenderType::Textured,
                    Event::KeyboardInput(ElementState::Released, 31, _) 
                        => render_kind = RenderType::WireFrame,
                    Event::KeyboardInput(ElementState::Released, 30, _)  =>
                                    cam.move_to(Point3::new(0.0, 65.0,-110.0)),
                    Event::KeyboardInput(_, x, _) => print!("key {}\n", x),
                    Event::Resized(w, h) => resizes.push((w,h)),
                    Event::MouseWheel(x,_) => match x{
                            glutin::MouseScrollDelta::LineDelta(_, y) =>
                                    cam.change_elevation(y*5.0),
                            _ => (),
                    },
                    _ => (),
                }
            }
        }
        
        // can not change window while context is borrowed
        for (w, h) in resizes{
            ctx.resize(w,h);
            // FIXME, this is a fix
            perspective_matrix = perspective(deg(45.0), w as f32 / h as f32, NEAR, FAR);
        }

    }, 5); // refresh every 5 secs

}
